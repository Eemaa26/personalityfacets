#' @title Bootstrap estimate of popualtion r-square of difference between facets and factors
#' 
#' @description The function provides a bootstrapped estimate with confidence intervals of of population r-squared change. 
#' 
#' @param data data.frame
#' @param dv character scalar with name of dependent variable
#' @param ivs1 character vector of variable names in \code{data} typically corresponding to personality factors
#' @param ivs2 character vector of variable names in \code{data} typically corresponding to personality facets
#' @param iterations positive number indicating number of bootstrap iterations to run
#' @param ci number between 0 and 1 indicating size of bootstrap confidence interval. 
#' @param method See \code{method} argument for \link{adjusted_r_squared} function. 
#' Default value is .95 representing a 95\% confidence interval. 
#' @return 
#' an object of class boot_mean_cor_diff
#' \item{boot_results}{object of class boot resulting from bootstrapping analysis}
#' \item{cor_matrix1}{numeric matrix: correlation matrix between set1 variables}
#' \item{cor_matrix2}{numeric matrix: correlation matrix between set2 variables}
#' \item{mean_cor1}{numeric scalar: average correlation between set1 variables}
#' \item{mean_cor2}{numeric scalar: average correlation between set2 variables}
#' \item{set1, set2, data, iterations, ci, method}{copy of corresponding arguments}
#' @export
#' @details
#' Population r-square change is defined as
#' \deqn{\Delta\rho^2 = \rho^2_{ivs2} - \rho^2_{ivs1}}
#' Bootstrapping involves performing applying the formula for adjusted r-square twice, 
#' once to remove the bootstrap bias, and a second time to remove the bias inherent to the r-square formula.
#' There are several methods available (See \code{method} argument for \link{adjusted_r_squared} function). 
#' However, in general if you assume that the predictors are random then \code{olkinpratt} is a good option.
#' If you assume that the predictors are fixed, then \code{ezekiel} is a good option.
#' A rough guide to number of iterations: 100 for basic error checking; 1,000 for exploratory analyses; 
#' 10,000 minimum recommended for publication; 100,000+ preferable for publication where computing power allows.
#' 
#' 
#' @examples
#' data(facets_data); data(facets_meta)
#' bootstrap_r_squared_change(facets_data, facets_meta$swb[1], facets_meta$ipip_factors, facets_meta$ipip_facets)
bootstrap_r_squared_change <- function(data, dv, ivs1, ivs2, iterations=1000, ci=.95, method='ezekiel') {
    results <- list()
    bootstrapped_data <- lapply(seq(iterations), 
                                function(X) data[ sample(seq(nrow(data)), size=nrow(data), replace=TRUE), ])
    
    # sapply_pb is a wrapper for sapply that provides a progress bar
    results$theta_hats <- sapply_pb(bootstrapped_data, function(X) 
        double_adjusted_r_squared_change(X, dv, ivs1, ivs2, method=method))
    results$bootstrap_standard_error <- sd(results$theta_hats)/sqrt(iterations)
    results$sample_theta_hat <- adjusted_r_squared_change(data, dv, ivs1, ivs2)
    results$ci_level <- ci
    results$ci_values <-  quantile(results$theta_hats, c((1-ci) / 2, 1 - (1-ci)/2))
    results$se <- sd(results$theta_hats)
    results$mean <- mean(results$theta_hats)
    results$adjusted_rsquare <- list(
        ivs1=adjusted_r_squared(summary(regression(dv, ivs=ivs1, data=data))$r.squared, 
                                nrow(data), length(ivs1), method=method),
        ivs2=adjusted_r_squared(summary(regression(dv, ivs=ivs2, data=data))$r.squared, 
                                nrow(data), length(ivs2), method=method)
    )
    results$variables <- list(ivs1=ivs1, ivs2=ivs2)
    results$method <- method
    class(results) <- "bootstrap_r_squared_change"
    results
}

# Progress bar from:
# http://ryouready.wordpress.com/2010/01/11/progress-bars-in-r-part-ii-a-wrapper-for-apply-functions/
sapply_pb <- function(X, FUN, ...)
{
    env <- environment()
    pb_Total <- length(X)
    counter <- 0
    pb <- txtProgressBar(min = 0, max = pb_Total, style = 3)
    
    wrapper <- function(...){
        curVal <- get("counter", envir = env)
        assign("counter", curVal +1 ,envir=env)
        setTxtProgressBar(get("pb", envir=env), curVal +1)
        FUN(...)
    }
    res <- sapply(X, wrapper, ...)
    close(pb)
    res
}
